#include "../include/USAC/PUTSLAMEstimator.h"

#include <opencv2/opencv.hpp>
#include <Eigen/Eigen>

#include "../include/TransformEst/g2oEst.h"

//// COPIED FROM PUTSLAM:
/**
* Method used to compute transformation model based on:
* prevFeatures				-- 	first set of 3D features
* features					--	second set of 3D features
* matches					-- 	vector of matches used in model creation
* transformationModel		-- 	computed transformation saved as a 4x4 matrix
* usedType					-- 	algorithm used in transformation estimation
*/
// - how to handle Grisetti version?
bool PUTSLAMEstimator::computeTransformationModel(
	const std::vector<Eigen::Vector3f> prevFeatures,
	const std::vector<Eigen::Vector3f> features,
	const std::vector<cv::DMatch> matches,
	Eigen::Matrix4f &transformationModel, TransfEstimationType usedType) {

	Eigen::MatrixXf prevFeaturesMatrix(matches.size(), 3), featuresMatrix(
		matches.size(), 3);

	// Create matrices
	for (int j = 0; j < matches.size(); j++) {
		cv::DMatch p = matches[j];
		prevFeaturesMatrix.block<1, 3>(j, 0) = prevFeatures[p.queryIdx];
		featuresMatrix.block<1, 3>(j, 0) = features[p.trainIdx];
	}

	// Compute transformation
	if (usedType == UMEYAMA) {
		transformationModel = Eigen::umeyama(featuresMatrix.transpose(),
			prevFeaturesMatrix.transpose(), false);
	}
	else if (usedType == G2O) {
		putslam::TransformEst* g2oEst = putslam::createG2OEstimator();
		Mat34 transformation = g2oEst->computeTransformation(
			featuresMatrix.cast<double>().transpose(),
			prevFeaturesMatrix.cast<double>().transpose());
		transformationModel = transformation.cast<float>().matrix();
	}
	else {
		std::cout << "RANSAC: unrecognized transformation estimation"
			<< std::endl;
	}

	// Check if it failed
	if (std::isnan(transformationModel(0, 0))) {
		transformationModel = Eigen::Matrix4f::Identity();
		return false;
	}
	return true;
}

// ============================================================================================
// generateMinimalSampleModels: generates minimum sample model(s) from the data points whose  
// indices are currently stored in m_sample. 
// the generated models are stored in a vector of models and are all evaluated
// ============================================================================================
unsigned int PUTSLAMEstimator::generateMinimalSampleModels()
{
	// MF:
	// solution dependes on the task, here copied from PUTSLAM computeTransformationModel method
	// FundmatrixEstimator is using something specialized 
	// HomogEstimator is using something specialized 
	unsigned int nsols = 0;

	// IMPORTANT - convert samples generated by USAC to the standard used in PUTSLAM
	this->randomMatches = this->convertUSACSamplesToPUTSLAMSamples(
		this->min_sample_,
		this->matches
	);

	if (this->computeTransformationModel(
			this->prevFeatures,
			this->features,
			this->randomMatches,
			this->transformationModel,
			this->usedType)
		)
	{
		nsols = 1;
	}
	else
	{
		std::cout << "PUTSLAMEstimator: generation model step: no solutions found" << std::endl;
	}

	// MF:
	// there is only one solution in PUTSLAM if it goes right, 0 otherwise	
	// solution stored in this->transformationModel
	return nsols;
}
